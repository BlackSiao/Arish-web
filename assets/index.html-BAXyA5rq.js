import{_ as e,c as i,b as s,o as a}from"./app-DNjG2iId.js";const l={};function n(r,t){return a(),i("div",null,[...t[0]||(t[0]=[s('<h1 id="http-与-tcp-的关系详解" tabindex="-1"><a class="header-anchor" href="#http-与-tcp-的关系详解"><span>HTTP 与 TCP 的关系详解</span></a></h1><h2 id="_1-http-与-tcp-的关系" tabindex="-1"><a class="header-anchor" href="#_1-http-与-tcp-的关系"><span>1. HTTP 与 TCP 的关系</span></a></h2><ul><li>HTTP 本身是应用层协议，它定义了浏览器和服务器之间如何组织与解释请求和响应。</li><li>HTTP 并不是“直接使用 TCP”，而是<strong>通常基于 TCP 来传输数据</strong>（HTTP/1.1、HTTP/2 使用 TCP；而HTTP/3 使用 QUIC/UDP）。</li><li>在计算机系统中，TCP 既是一份协议规范（RFC 文档），也有<strong>实际实现</strong>：通常由操作系统内核的 <strong>TCP/IP 协议栈</strong>负责。</li></ul><hr><h2 id="_2-浏览器请求网页的过程" tabindex="-1"><a class="header-anchor" href="#_2-浏览器请求网页的过程"><span>2. 浏览器请求网页的过程</span></a></h2><ol><li><p><strong>DNS 解析</strong>：浏览器将域名解析为服务器 IP。</p></li><li><p><strong>建立连接</strong>：浏览器通过 Socket API（如 <code>socket()</code> + <code>connect()</code>）向服务器发起 TCP 连接。</p><ul><li><p>客户端会随机选择一个 <strong>临时端口</strong>（ephemeral port），例如 52341。</p></li><li><p>服务器监听在 <strong>443 端口</strong>（HTTPS），或 80 端口（HTTP）。</p></li><li><p>连接实际上是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>客户端IP:52341  &lt;——TCP连接——&gt;  服务器IP:443</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><p><strong>三次握手</strong>：TCP 建立连接，确保可靠传输通道存在。</p></li><li><p><strong>TLS 握手（若为 HTTPS）</strong>：在 TCP 连接上进行 TLS 加密协商。</p></li><li><p><strong>传输数据</strong>：浏览器发送 HTTP 请求报文，服务器返回 HTTP 响应报文。</p></li></ol><hr><h2 id="_3-http-报文送到-tcp-是什么意思" tabindex="-1"><a class="header-anchor" href="#_3-http-报文送到-tcp-是什么意思"><span>3. “HTTP 报文送到 TCP”是什么意思？</span></a></h2><ul><li><p>从应用层（HTTP 客户端）角度：调用 <strong>Socket API</strong>（如 <code>send()</code>），把 HTTP 报文交给操作系统。</p></li><li><p>在操作系统内部：</p><ol><li>内核的 <strong>TCP 模块</strong>接收报文字节，放进 <strong>发送缓冲区</strong>。</li><li>TCP 协议栈将报文切分为合适大小的 <strong>TCP 段（segment）</strong>。</li><li>每个段加上 TCP 头部（端口、序列号、校验和等）。</li><li>交给 IP 层，继续封装为 IP 数据报。</li><li>最终交给链路层/物理层，经由网卡发出。</li></ol></li></ul><p>因此，“送到 TCP”实际上就是：<strong>应用层把数据交给内核的 TCP 协议栈，由它负责分段、加头、传递给下层。</strong></p><hr><h2 id="_4-tcp-的物理实现" tabindex="-1"><a class="header-anchor" href="#_4-tcp-的物理实现"><span>4. TCP 的物理实现</span></a></h2><ul><li>TCP 不是硬件，而是<strong>操作系统内核里的一个软件模块</strong>： <ul><li>运行在 CPU 上。</li><li>使用内存缓冲区存放待发送和接收的数据。</li></ul></li><li>网卡只懂链路层和物理层，它并不了解 TCP 协议。 <ul><li>网卡收发的是以太网帧。</li><li>报文送到主机后，由驱动交给内核协议栈，逐层剥离直到 TCP 层。</li></ul></li></ul><hr><h2 id="_5-http是无状态协议" tabindex="-1"><a class="header-anchor" href="#_5-http是无状态协议"><span>5. HTTP是无状态协议</span></a></h2><p>在服务器向客户发送被请求的文件时，服务器本身不会存储任何关于该客户的状态信息。比如说某个客户在几秒内多次重复 请求同一个对象，服务器并不会因为刚刚为该客户提供此对象就不再做出反应，而是重新发送该对象，就像服务器已经忘记 之前做过的事情一样。这也就是为什么常说 HTTP协议是一个无状态协议</p>',16)])])}const p=e(l,[["render",n]]),c=JSON.parse('{"path":"/notes/Internet/s1hevuji/","title":"protocol","lang":"zh-CN","frontmatter":{"title":"protocol","createTime":"2025/09/24 20:30:18","permalink":"/notes/Internet/s1hevuji/"},"readingTime":{"minutes":2.39,"words":716},"git":{"createdTime":1759802183000,"updatedTime":1759802183000,"contributors":[{"name":"BlackSiao","username":"BlackSiao","email":"1546600539@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/BlackSiao?v=4","url":"https://github.com/BlackSiao"}]},"filePathRelative":"notes/Internet/protocol.md","headers":[]}');export{p as comp,c as data};
