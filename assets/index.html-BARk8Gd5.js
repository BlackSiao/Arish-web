import{_ as s,c as a,d as n,o as e}from"./app-UDSOE8tV.js";const t={};function l(h,i){return e(),a("div",null,[...i[0]||(i[0]=[n(`<div class="language-markdown line-numbers-mode" data-highlighter="shiki" data-ext="markdown" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-markdown"><span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">##</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> 挂载（mount）到底是什么意思？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">简单来说，</span><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">**</span><span style="--shiki-light:#393A34;--shiki-light-font-weight:bold;--shiki-dark:#DBD7CAEE;--shiki-dark-font-weight:bold;">挂载（mount）</span><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">**</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 就是把一个“设备”或“文件”里的内容，</span><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">**</span><span style="--shiki-light:#393A34;--shiki-light-font-weight:bold;--shiki-dark:#DBD7CAEE;--shiki-dark-font-weight:bold;">映射</span><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">**</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">到 Linux 文件系统目录树中的某个目录下，让它看起来像是本来就“长”在这个目录里一样。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">把 Linux 的文件系统想象成一棵以 </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">/</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 为根的大树：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#D4976C;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 目前这棵树上只有一些“原生”的目录和文件（</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">/bin</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">、</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">/etc</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">、</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">/home</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">、</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">/var</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 等）。</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#D4976C;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 但你的电脑或服务器上还有很多其他“东西”：硬盘分区、U盘、移动硬盘、光盘（ISO镜像）、网盘、虚拟磁盘、其他分区，甚至 Windows 的 NTFS 分区……</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">**</span><span style="--shiki-light:#393A34;--shiki-light-font-weight:bold;--shiki-dark:#DBD7CAEE;--shiki-dark-font-weight:bold;">mount 的作用</span><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">**</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">：把这些“外来”的东西接驳到这棵大树上的某个空目录里，让它们成为树的一部分，成为文件系统可见、可访问的内容。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">###</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> 为什么不能直接操作 </span><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">\`</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;">/dev/sda</span><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">\`</span><span style="--shiki-light:#1C6B48;--shiki-light-font-weight:bold;--shiki-dark:#4D9375;--shiki-dark-font-weight:bold;"> 里的“文件夹”？为什么非要先 mount？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">一句话解释：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">**</span><span style="--shiki-light:#393A34;--shiki-light-font-weight:bold;--shiki-dark:#DBD7CAEE;--shiki-dark-font-weight:bold;">/dev/sda 根本就没有文件夹</span><span style="--shiki-light:#999999;--shiki-light-font-weight:bold;--shiki-dark:#666666;--shiki-dark-font-weight:bold;">**</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">，它只是一个“生肉”数据通道，里面存的是一堆连续的字节序列，而不是大家所熟悉的文件和目录结构。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">你不能这样做（都会失败）：</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">\`\`\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">bash</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">cd</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /dev/sda</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">               # 错误！/dev/sda 不是目录</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">ls</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /dev/sda</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">               # 错误！/dev/sda 不是目录</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">cat</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /dev/sda/file.txt</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">     # 错误！根本没有 file.txt 这个概念</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 <code>/dev/sda</code> 本身不包含任何文件系统结构（没有 inode、目录树、文件名等信息），它只是内核暴露给用户的原始块设备接口。</p><h3 id="分区的概念" tabindex="-1"><a class="header-anchor" href="#分区的概念"><span>分区的概念</span></a></h3><p>大多数情况下，你不会直接操作整块磁盘 <code>/dev/sda</code>，而是操作它的<strong>分区</strong>（如 <code>/dev/sda1</code>、<code>/dev/sda2</code> 等）。</p><p>即使是分区，<code>/dev/sda1</code> 也仍然只是“生肉数据块”：</p><ul><li>它代表磁盘上从某个起始扇区到结束扇区的一段连续字节。</li><li>这段字节可能被格式化成了 ext4、xfs、ntfs、fat32、exfat 等文件系统。</li><li>但<strong>内核默认并不知道</strong>这段字节应该怎么解读成文件和目录。</li></ul><p>所以，必须通过 <code>mount</code> 命令告诉内核：“请按照 ext4 的规则来解读 /dev/sda1 里的数据，并把它挂载到 /mnt/data 目录下”。</p><h3 id="为什么-linux-要设计成这样-而不是像-windows-那样自动分配盘符" tabindex="-1"><a class="header-anchor" href="#为什么-linux-要设计成这样-而不是像-windows-那样自动分配盘符"><span>为什么 Linux 要设计成这样？（而不是像 Windows 那样自动分配盘符）</span></a></h3><p>Linux 的核心哲学：</p><ul><li><strong>一切皆文件</strong>，但<strong>设备</strong>和<strong>文件系统</strong>是两层完全不同的概念。</li><li>内核只负责提供最原始、最干净的块设备接口（<code>/dev/sd*</code>、<code> /dev/nvme*</code> 等）。</li><li>具体“这个块设备要怎么用、挂在哪里”，完全由<strong>用户或系统管理员</strong>决定。</li></ul><p>这种设计带来了极大的灵活性：</p><ul><li>你可以把多个分区挂载到目录树的不同位置。</li><li>支持覆盖挂载（overlay）。</li><li>支持 bind mount（把一个目录绑定到另一个位置）。</li><li>支持网络文件系统（NFS、CIFS/SMB、SSHFS）。</li><li>支持 tmpfs、ramfs、加密设备（LUKS）、循环设备（loop mount ISO）、容器 overlay 等。</li></ul><h3 id="新插的硬盘-ssd-能不能直接-mount" tabindex="-1"><a class="header-anchor" href="#新插的硬盘-ssd-能不能直接-mount"><span>新插的硬盘/SSD 能不能直接 mount？</span></a></h3><p><strong>大多数情况下不行</strong>。</p><p>即使新硬盘被内核识别出现在 <code>/dev/</code> 下（比如 <code>/dev/sdb</code>），你也不能直接 <code>mount /dev/sdb /mnt</code>，除非它同时满足以下条件：</p><ol><li>已经有分区（比如 <code>/dev/sdb1</code>，而不是只有 <code>/dev/sdb</code>）</li><li>分区上已经有文件系统（ext4、xfs、ntfs、exfat 等）</li><li>文件系统是当前内核支持的，并且没有严重损坏</li></ol><p>如果缺少分区或文件系统，你需要先用 <code>fdisk</code>、<code>parted</code>、<code>gdisk</code> 等工具分区，再用 <code>mkfs.ext4</code>、<code>mkfs.xfs</code> 等格式化，然后才能挂载。</p><p>一句话总结：</p><p><strong>mount 是“让内核知道怎么解读一块生肉，并把它接入文件系统树”的过程</strong>，没有 mount，设备里的内容对用户来说就是不可见的字节流。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,20)])])}const k=s(t,[["render",l]]),p=JSON.parse('{"path":"/notes/Linux/23wfqm2y/","title":"mount(挂载)","lang":"zh-CN","frontmatter":{"title":"mount(挂载)","createTime":"2026/02/10 15:42:25","permalink":"/notes/Linux/23wfqm2y/","description":"因为 /dev/sda 本身不包含任何文件系统结构（没有 inode、目录树、文件名等信息），它只是内核暴露给用户的原始块设备接口。 分区的概念 大多数情况下，你不会直接操作整块磁盘 /dev/sda，而是操作它的分区（如 /dev/sda1、/dev/sda2 等）。 即使是分区，/dev/sda1 也仍然只是“生肉数据块”： 它代表磁盘上从某个起始...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"mount(挂载)\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-10T08:07:34.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://blackhsiao.com/notes/Linux/23wfqm2y/"}],["meta",{"property":"og:site_name","content":"Black Hsiao 的技术笔记"}],["meta",{"property":"og:title","content":"mount(挂载)"}],["meta",{"property":"og:description","content":"因为 /dev/sda 本身不包含任何文件系统结构（没有 inode、目录树、文件名等信息），它只是内核暴露给用户的原始块设备接口。 分区的概念 大多数情况下，你不会直接操作整块磁盘 /dev/sda，而是操作它的分区（如 /dev/sda1、/dev/sda2 等）。 即使是分区，/dev/sda1 也仍然只是“生肉数据块”： 它代表磁盘上从某个起始..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-10T08:07:34.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-10T08:07:34.000Z"}]]},"readingTime":{"minutes":3.14,"words":942},"git":{"createdTime":1770710854000,"updatedTime":1770710854000,"contributors":[{"name":"BlackSiao","username":"BlackSiao","email":"1546600539@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/BlackSiao?v=4","url":"https://github.com/BlackSiao"}]},"autoDesc":true,"filePathRelative":"notes/Linux/mount(挂载).md","headers":[]}');export{k as comp,p as data};
