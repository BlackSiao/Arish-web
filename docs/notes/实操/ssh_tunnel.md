# ssh_tunnel

## 一、ssh_tunnel 是什么？解决什么问题？

`ssh_tunnel`（SSH 端口转发）是一种**非常实用且高效**的技术。

在真实的生产环境中，尤其是：

- 内网 / 外网严格隔离  
- 大量端口被防火墙封禁  
- 只能通过 SSH 登录到少数“跳板机”  
- 内网服务（Web / BMC / API / DB）不对外暴露  

这种情况下，我们**无法直接从本地访问内网机器提供的服务端口**（例如 443、8443、3306 等）。

但只要满足一个条件：

> **你能通过 SSH 登录到某台能访问目标内网机器的主机**

那么就可以利用 **ssh_tunnel**，把：

> 本地某个端口  
→ 通过 SSH 加密通道  
→ 转发到内网目标机器的某个端口

从而实现：

- 本地浏览器直接访问内网 Web / BMC
- 本地工具访问内网 API / 数据库
- 不需要在防火墙上额外放行端口

一句话总结：

> **ssh_tunnel = 用 SSH 当“加密管道”，偷偷把内网服务搬到你本地用**

---

## 二、为什么 ssh_tunnel 特别有用？

在很多公司 / IDC 场景中：

- 内网 IP（如 `192.168.x.x`）外部不可达  
- BMC / 管理口只允许内网访问  
- 防火墙只放行 22（SSH）

这时你可能遇到的问题是：

- 能 `ssh` 登录，但浏览器打不开页面  
- 能 `curl`，但只能在服务器上看  
- 想在**自己电脑**上用浏览器 / 工具操作

ssh_tunnel 正好解决了这个“**最后一公里**”的问题。

---

## 三、ssh_tunnel 的基本语法

### 1️⃣ 本地端口转发（最常用）

```bash
ssh -L 本地端口:目标IP:目标端口 user@跳板机
````

含义是：

> 把 **本地端口** > 转发到 **跳板机能访问的目标IP:目标端口**

例如：

```bash
ssh -L 8443:192.168.10.108:443 root@38.95.160.2
```

意思是：

* 在**当前执行命令的这台机器上**
* 打开 `127.0.0.1:8443`
* 所有流量通过 SSH
* 转发到 `192.168.10.108:443`

---

### 2️⃣ 常用参数说明

```bash
-N   # 不执行远端命令（只建隧道）
-f   # 放到后台
-C   # 压缩（慢链路有用）
-v   # 调试模式（排错非常有用）
```

## 四、结合我最近的真实场景来说明

### 场景结构

```
[ 本地 Windows ]
        |
        |  SSH
        v
[ 跳板机 10.0.0.20 ]
        |
        |  SSH
        v
[ 管理机 38.95.160.2 ]
        |
        |  内网
        v
[ BMC 192.168.10.108:443 ]
```

特点：

* `192.168.10.108` 是**私网地址**
* 本地无法 ping
* 跳板机也无法直达
* **管理机可以访问 BMC**

---

### 目标

> 在**我自己的电脑浏览器**里
> 访问 `https://192.168.10.108` 的 BMC 管理界面

---

### 正确做法（核心思路）

> **ssh_tunnel 建在哪台机器上，端口就开在哪台机器上**

#### 情况 A：在【本地电脑】建隧道（最理想）

```bash
ssh -N \
  -L 8443:192.168.10.108:443 \
  -J root@10.0.0.20 \
  root@38.95.160.2
```

然后在本地浏览器访问：

```
https://127.0.0.1:8443
```

> 前提：
>
> * 本地能免密 / 输入密码登录 `38.95.160.2`
> * 或本地有它的 SSH 私钥

---

#### 情况 B：只能在【跳板机】上建隧道

```bash
ssh -N -L 8443:192.168.10.108:443 root@38.95.160.2
```

此时：

* 端口 **8443 开在跳板机**
* 本地访问 `127.0.0.1:8443` ❌ 是没用的

你还需要 **第二层隧道**：

```bash
ssh -N -L 9443:127.0.0.1:8443 root@10.0.0.20
```

最终访问：

```
https://127.0.0.1:9443
```

---

## 五、一个非常容易踩坑的点（你也踩过）

### ❗ ssh -L 里的 `127.0.0.1` 是“执行命令的那台机器”

```bash
ssh -L 8443:192.168.10.108:443 root@38.95.160.2
```

不是：

* 给远端机器开端口
* 也不是自动给公网开端口

而是：

> **在“当前 shell 所在的机器”监听端口**

所以你当时会疑惑：

> “我明明是在跳板机上 ssh -L，为什么是 localhost？”

答案是：

> localhost = 跳板机本身

---

## 六、为什么 ss / netstat 看不到 ssh_tunnel？

这是 ssh_tunnel 的一个**非常反直觉但很重要的点**。

### 1️⃣ ssh_tunnel 不是普通监听服务

* 没有真正的 daemon
* 不在 iptables FORWARD 链
* 不走常规 socket 转发逻辑

它是：

> **SSH 进程内部实现的端口转发**

---

### 2️⃣ 所以你会看到这些现象

```bash
ss -tulnp | grep 8443
```

可能：

* 什么都看不到
* 或只看到 `ssh` 进程
* curl 能通，但浏览器访问不到（绑定地址问题）

这是**正常的，不是故障**

---

## 七、排错时非常有用的技巧

### 开调试模式

```bash
ssh -v -N -L 8443:192.168.10.108:443 root@38.95.160.2
```

重点看：

* `Local forwarding listening on ...`
* `channel open`
* 有没有 `bind: Address already in use`

---

### SSL 报错是好事

```bash
curl -k https://127.0.0.1:8443
```

看到：

```text
self-signed certificate
```

说明：

> **隧道是通的，只是证书不受信任**

---

## 八、一句话经验总结

* ssh_tunnel 是 **“谁执行，端口就开在哪”**
* 浏览器在哪，就要在哪建 tunnel
* 一层不够，就两层
* SSL 报错 ≠ 网络不通
* ss / iptables 看不到 ≠ tunnel 不存在

---

如果你愿意，我可以帮你下一步做的是：

* 把这套 **“多跳 SSH + Tunnel”** 画成一张结构图
* 帮你总结一个 **排错 checklist**
* 或直接给你一份 **「运维常用 SSH 隧道模板」**

你一句话我就继续 😄
