---
title: mount(挂载)
createTime: 2026/02/10 15:42:25
permalink: /notes/Linux/23wfqm2y/
---

```markdown
## 挂载（mount）到底是什么意思？

简单来说，**挂载（mount）** 就是把一个“设备”或“文件”里的内容，**映射**到 Linux 文件系统目录树中的某个目录下，让它看起来像是本来就“长”在这个目录里一样。

把 Linux 的文件系统想象成一棵以 `/` 为根的大树：

- 目前这棵树上只有一些“原生”的目录和文件（`/bin`、`/etc`、`/home`、`/var` 等）。
- 但你的电脑或服务器上还有很多其他“东西”：硬盘分区、U盘、移动硬盘、光盘（ISO镜像）、网盘、虚拟磁盘、其他分区，甚至 Windows 的 NTFS 分区……

**mount 的作用**：把这些“外来”的东西接驳到这棵大树上的某个空目录里，让它们成为树的一部分，成为文件系统可见、可访问的内容。

### 为什么不能直接操作 `/dev/sda` 里的“文件夹”？为什么非要先 mount？

一句话解释：

**/dev/sda 根本就没有文件夹**，它只是一个“生肉”数据通道，里面存的是一堆连续的字节序列，而不是大家所熟悉的文件和目录结构。

你不能这样做（都会失败）：
```bash
cd /dev/sda               # 错误！/dev/sda 不是目录
ls /dev/sda               # 错误！/dev/sda 不是目录
cat /dev/sda/file.txt     # 错误！根本没有 file.txt 这个概念
```

因为 `/dev/sda` 本身不包含任何文件系统结构（没有 inode、目录树、文件名等信息），它只是内核暴露给用户的原始块设备接口。

### 分区的概念

大多数情况下，你不会直接操作整块磁盘 `/dev/sda`，而是操作它的**分区**（如 `/dev/sda1`、`/dev/sda2` 等）。

即使是分区，`/dev/sda1` 也仍然只是“生肉数据块”：

- 它代表磁盘上从某个起始扇区到结束扇区的一段连续字节。
- 这段字节可能被格式化成了 ext4、xfs、ntfs、fat32、exfat 等文件系统。
- 但**内核默认并不知道**这段字节应该怎么解读成文件和目录。

所以，必须通过 `mount` 命令告诉内核：“请按照 ext4 的规则来解读 /dev/sda1 里的数据，并把它挂载到 /mnt/data 目录下”。

### 为什么 Linux 要设计成这样？（而不是像 Windows 那样自动分配盘符）

Linux 的核心哲学：

- **一切皆文件**，但**设备**和**文件系统**是两层完全不同的概念。
- 内核只负责提供最原始、最干净的块设备接口（`/dev/sd*`、` /dev/nvme*` 等）。
- 具体“这个块设备要怎么用、挂在哪里”，完全由**用户或系统管理员**决定。

这种设计带来了极大的灵活性：

- 你可以把多个分区挂载到目录树的不同位置。
- 支持覆盖挂载（overlay）。
- 支持 bind mount（把一个目录绑定到另一个位置）。
- 支持网络文件系统（NFS、CIFS/SMB、SSHFS）。
- 支持 tmpfs、ramfs、加密设备（LUKS）、循环设备（loop mount ISO）、容器 overlay 等。

### 新插的硬盘/SSD 能不能直接 mount？

**大多数情况下不行**。

即使新硬盘被内核识别出现在 `/dev/` 下（比如 `/dev/sdb`），你也不能直接 `mount /dev/sdb /mnt`，除非它同时满足以下条件：

1. 已经有分区（比如 `/dev/sdb1`，而不是只有 `/dev/sdb`）
2. 分区上已经有文件系统（ext4、xfs、ntfs、exfat 等）
3. 文件系统是当前内核支持的，并且没有严重损坏

如果缺少分区或文件系统，你需要先用 `fdisk`、`parted`、`gdisk` 等工具分区，再用 `mkfs.ext4`、`mkfs.xfs` 等格式化，然后才能挂载。

一句话总结：

**mount 是“让内核知道怎么解读一块生肉，并把它接入文件系统树”的过程**，没有 mount，设备里的内容对用户来说就是不可见的字节流。
```

